# grep
- [grep](#grep)
	- [書式](#書式)
	- [正規表現の選択](#正規表現の選択)
	- [マッチングの制御](#マッチングの制御)
		- [PATTERNを指定 -e PATTERN, --regexp=PATTERN](#patternを指定--e-pattern---regexppattern)
		- [FILEから1行1パターンとして読み込み -f FILE, --file=FILE](#fileから1行1パターンとして読み込み--f-file---filefile)
		- [大文字と小文字を区別しない -i, --ignore-case](#大文字と小文字を区別しない--i---ignore-case)
		- [マッチしない行を抜き出す -v, --invert-match](#マッチしない行を抜き出す--v---invert-match)
		- [マッチする部分が完全な単語 -w, --word-regexp](#マッチする部分が完全な単語--w---word-regexp)
		- [行全体と完全にマッチしたとき -x, --line-regexp](#行全体と完全にマッチしたとき--x---line-regexp)
	- [一般的な出力の制御](#一般的な出力の制御)
		- [マッチした行数を表示 -c, --count](#マッチした行数を表示--c---count)
		- [--color[=WHEN], --colour[=WHEN]](#--colorwhen---colourwhen)
		- [マッチしないファイルの名前 -L, --files-without-match](#マッチしないファイルの名前--l---files-without-match)
		- [マッチがあるファイルの名前 -l, --files-with-matches](#マッチがあるファイルの名前--l---files-with-matches)
		- [-m NUM, --max-count=NUM](#-m-num---max-countnum)
		- [マッチした部分だけ](#マッチした部分だけ)
		- [-q, --quiet, --silent](#-q---quiet---silent)
		- [-s, --no-messages](#-s---no-messages)
	- [出力する行の前に付ける情報の制御 -b, --byte-offset](#出力する行の前に付ける情報の制御--b---byte-offset)
		- [マッチするファイル名を表示する -H, --with-filename](#マッチするファイル名を表示する--h---with-filename)
		- [ファイル名を表示しない -h, --no-filename](#ファイル名を表示しない--h---no-filename)
		- [--label=LABEL](#--labellabel)
		- [マッチする行番号を表示 -n, --line-number](#マッチする行番号を表示--n---line-number)
		- [表示を揃える -T, --initial-tab](#表示を揃える--t---initial-tab)
		- [NUL文字を出力 -Z, --null](#nul文字を出力--z---null)
	- [前後の文脈行の制御](#前後の文脈行の制御)
		- [マッチした行の後に続く行を表示 -A NUM, --after-context=NUM](#マッチした行の後に続く行を表示--a-num---after-contextnum)
		- [マッチした行の前の行を表示 -B NUM, --before-context=NUM](#マッチした行の前の行を表示--b-num---before-contextnum)
		- [マッチした行の前後の行を表示 -C NUM, -NUM, --context=NUM](#マッチした行の前後の行を表示--c-num--num---contextnum)
	- [ファイルやディレクトリの選択](#ファイルやディレクトリの選択)
		- [-a, --text](#-a---text)
		- [--binary-files=TYPE](#--binary-filestype)
		- [--exclude=GLOB](#--excludeglob)
		- [--exclude-from=FILE](#--exclude-fromfile)
		- [--exclude-dir=GLOB](#--exclude-dirglob)
		- [-I](#-i)
		- [--include=GLOB](#--includeglob)
		- [-r, --recursive](#-r---recursive)
		- [-R, --dereference-recursive](#-r---dereference-recursive)
	- [その他のオプション](#その他のオプション)
		- [--line-buffered](#--line-buffered)
		- [-U, --binary](#-u---binary)
		- [-z, --null-data](#-z---null-data)

https://linuxjm.osdn.jp/html/GNU_grep/man1/grep.1.html
を要約したり例を作ったりしたい

## 書式
- grep [OPTIONS] PATTERN [FILE...]
- grep [OPTIONS] [-e PATTERN | -f FILE] [FILE...]

## 正規表現の選択
-E, --extended-regexp
PATTERNを拡張正規表現 (ERE) として扱います (下記参照)。
-F, --fixed-strings
PATTERNを改行で区切られた固定文字列 (正規表現のかわりに) のリストとして扱い、その文字列のいずれかとマッチするかどうかを調べます。
-G, --basic-regexp
PATTERNを基本正規表現 (BRE) として扱います (下記参照)。これがデフォルトです。
-P, --perl-regexp
パターンをPerl互換の正規表現 (PCRE) として扱います。きわめて実験的なものなので、grep -Pを使うと、その機能は実装されていませんという警告が出るかもしれません。

## マッチングの制御
### PATTERNを指定 -e PATTERN, --regexp=PATTERN
- PATTERNを指定します。
- パターンが1つのときは省略して使われることがある。2つ以上のときは必ず指定。
- 複数回使ったときや、 -f (--file) と組み合わせたときは、すべてのパターンを検索します。
- このオプションは、ハイフン ``-'' で始まるパターンを保護するのにも使えます。

```
# ハイフンで始まるパターンでエラー
echo "This --is mine." | grep "--is"
grep: unrecognized option '--is'
Usage: grep [OPTION]... PATTERNS [FILE]...
Try 'grep --help' for more information.

# -eを使うとOK
echo "This --is mine." | grep -e "--is"
This --is mine.
```

### FILEから1行1パターンとして読み込み -f FILE, --file=FILE
- パターンをFILEから1行1パターンとして読み込みます。
- 複数回使ったときや、 -e (--regexp) オプションと組み合わせたときは、すべてのパターンを検索します。
- 空のファイルはパターンを含まないので、何にもマッチしません。

### 大文字と小文字を区別しない -i, --ignore-case
PATTERNと入力ファイルで、大文字と小文字を区別しないようにします。

### マッチしない行を抜き出す -v, --invert-match
マッチしない行を抜き出す

### マッチする部分が完全な単語 -w, --word-regexp
- マッチする部分が完全な単語を形成するときのみその行を選択
- 条件:空白、改行、引用符、句読点などで前後を区切られた文字列
  - たとえば、文字列「A word with you」中のwordという部分文字列は完全な単語ですが、文字列「two words」中の部分文字列wordは完全な単語を形成しません)。
  - 単語構成文字とは、アルファベット、数字、アンダスコア (訳注: 実は漢字や仮名も単語構成文字として扱われます)。
  - -xが同時に指定されたときには無効

### 行全体と完全にマッチしたとき -x, --line-regexp
パターンが行全体と完全にマッチしたときにのみ、その行を選択します。

**-y**
-iと同じ意味を持つ旧式のオプション

## 一般的な出力の制御
### マッチした行数を表示 -c, --count
通常の出力はせず、各入力ファイルについてマッチした行数を表示します。 -v, --invert-matchオプション (上記参照) と共に指定した場合は、マッチしなかった行数を表示します。

### --color[=WHEN], --colour[=WHEN]
- マッチした (空文字列ではない) 文字列、マッチする行、前後の文脈行、ファイル名、行番号、バイトオフセット、(フィールドや、前後の文脈行を含むグループ同士の) 区切り記号をエスケープ・シーケンスで囲み、ターミナル上に色付きで表示します。
- どの色を使うかは、環境変数GREP_COLORSで定義します。非推奨の環境変数GREP_COLORも、これまでどおり使用できますが、その設定は優先されません。WHENはnever, always, autoのいずれかです。

### マッチしないファイルの名前 -L, --files-without-match
- grepで何もマッチしないファイルの名前を出力
```
# ファイル名は列挙できる。
grep -l That file1.txt file2.txt
```
### マッチがあるファイルの名前 -l, --files-with-matches
- grepでマッチがあるファイルの名前を出力

### -m NUM, --max-count=NUM
TODO
マッチした行数がNUMに達したら、ファイルの読み込みを中止します。入力が通常ファイルから標準入力を介して行われている場合は、マッチした行をNUM行出力した時点で、grepは標準入力の読み出し位置を最後にマッチした行の直後に来るようにしてから、終了します。続いて表示する文脈行がある場合でも、この動作は変わりません。このことは、grepを呼び出すプロセスが、中止したところから検索を再開することを可能にします。grepはマッチした行数がNUMに達してストップしたとき、それに続く文脈行があれば、それを出力します。 -cや --countオプションを同時に使用した場合、grepはNUMよりも大きい数を出力しません。 -vや --invert-matchを同時に使用した場合は、マッチしない行をNUM行出力したところで、grepはストップします。

### マッチした部分だけ
-o, --only-matching
マッチする行のマッチした部分だけを (それが空文字列でなければ) 表示します。マッチした各文字列は、それぞれ別の行に書き出します。

### -q, --quiet, --silent
沈黙モードです。標準出力に何も書き出しません。マッチするものが1つでも見つかると、エラーを検出していた場合でも、終了ステータス0で即座に終了します。

### -s, --no-messages
ファイルが存在しないことや読み込みめないことを示すエラーメッセージを抑止します。

## 出力する行の前に付ける情報の制御 -b, --byte-offset
- 出力する各行の前に、その行が何バイト目から始まるかのオフセットを表示。ファイルの最初が0。
- -o (--only-matching) も指定されているときは、マッチする部分そのもののオフセットを示します。

```
echo $'This is mine.\nThat is yours.' | grep -b is
0:This is mine.
14:That is yours.
```
### マッチするファイル名を表示する -H, --with-filename
各々のマッチに対してそのファイル名を表示します。検索するファイルが2個以上の場合は、これがデフォルトの動作です。

### ファイル名を表示しない -h, --no-filename
出力する行の前にファイル名を付けないようにします。検索するファイルが1つしかない (あるいは、標準入力だけだった) 場合は、これがデフォルトの動作です。

TODO???
### --label=LABEL
実際には標準入力から来た入力をLABELというファイルから来たもののように見せかけます。これはzgrepのようなツールを自分で作成する際にとりわけ便利です。たとえば、gzip -cd foo.gz | grep --label=foo -H somethingといった具合です。 -Hオプションも参照してください。

### マッチする行番号を表示 -n, --line-number
各出力行の前に、その入力ファイル内での1から始まる行番号を表示します。

### 表示を揃える -T, --initial-tab
行の実際の内容をなす最初の文字が、必ずタブ・ストップの位置に来るようにします。その結果、タブがきちんと揃って見えるようになります。このオプションは -H,-n,-bといった、実際の内容の前に情報を付加するオプションを使うときに役に立ちます。また、このオプションは、1つのファイルから抜き出した行の先頭ができるだけ揃うように、行番号やバイトオフセットがある場合は、そのフィールド幅を必要最小のサイズにして表示します。

```
# ずれる
echo $'This is mine.\nThat is yours.' | grep -b is
0:This is mine.
14:That is yours.

# 揃う。オフセットは自動？TODO
echo $'This is mine.\nThat is yours.' | grep -T -b is
                   0:   This is mine.
                  14:   That is yours.
```

**MSでUnix grepの結果を出す -u, --unix-byte-offsets**
- MS-DOSとMS-Windowsで、Unixマシンでgrepを実行したときと同じ結果を得るためのもの
  - -bオプションを同時に使用
- CR文字を切り捨て、検索対象のファイルがUnix形式のテキストファイルであるかのように、バイトオフセットを報告します。

### NUL文字を出力 -Z, --null
ファイル名に続いて通常出力される文字の代わりに、値が0の1バイト (ASCII NUL文字) を出力します。たとえば、grep -lZは、いつもの改行 (newline) ではなく、値が0の1バイトを各ファイル名の後ろに出力するのです。このオプションは、改行のような変わった文字を含むファイル名があるときでも、出力の曖昧さをなくしてくれます。このオプションをfind -print0, perl -0, sort -z, xargs -0などのコマンドと組み合わせて使うと、行儀の悪いファイル名も処理することができます。ファイル名が改行文字を含んでいても処理できるのです。

## 前後の文脈行の制御

ABC共通
- マッチした行を含むグループ同士の間には、グループを区切る印 (--) からなる行を置きます。
- -oや --only-matchingと同時に使うと、このオプションは効果がなく、警告メッセージを出します。

### マッチした行の後に続く行を表示 -A NUM, --after-context=NUM
NUMで指定した行数だけ、パターンにマッチした行の後に続く文も表示

### マッチした行の前の行を表示 -B NUM, --before-context=NUM
NUMで指定した行数だけ、パターンにマッチした行に先行する文も表示

### マッチした行の前後の行を表示 -C NUM, -NUM, --context=NUM
NUMで指定した行数だけ、パターンにマッチした行の前後の文も表示

## ファイルやディレクトリの選択
### -a, --text
バイナリファイルをテキストファイルであるかのように処理します。これは --binary-files=textオプションと等価です。

### --binary-files=TYPE
- ファイルにバイナリデータが含まれている場合に、ファイルのタイプをTYPEだと見なします。
  - テキストではないバイトが見つかれば、バイナリデータ
    - テキストではないバイトが、現在使用しているロケールに不適切にエンコードして出力されたバイト
    - -zが指定されていないときの入力中のヌルバイト
  - デフォルトではTYPEはbinary
    - grepはファイルがバイナリだとわかると、その先の出力を抑制
      - バイナリファイルにマッチしたという1行のメッセージを表示
      - マッチする部分がない場合には何も表示しません
  - TYPEがwithout-matchの場合、grepはファイルがバイナリだとわかると、残りはマッチしないものと仮定します。これは -Iオプションと等価です。
  - TYPEがtextの場合、grepはバイナリファイルをテキストであるかのように扱います。これは -aオプションと等価です。
  - typeがbinaryの場合、grepは -zがなくてもテキスト以外の文字を行の区切りとして扱う場合があります。これは、binaryを選ぶかtextを選ぶかによって、パターンがファイルにマッチするかどうかに影響があることを意味します。たとえば、typeがbinaryの場合はq$ というパターンがqの直後にNULL文字が続く箇所にマッチする可能性があるのに対し、typeがtextの場合にはマッチしません。逆に、typeがbinaryの場合、 . (period) というパターンはNULL文字にはマッチしないかもしれません。
警告: -aオプションはバイナリのゴミを出力するかもしれません。出力先が端末であり、しかも端末ドライバがゴミの一部をコマンドだと解釈する場合には、このゴミが厄介な副作用を起こす可能性があります。一方、テキストのエンコーディングが不明なファイルを読み込むとき、マッチした結果をそのまま表示するのが安全でなくても、より多くのマッチを探すために、 -aを指定するか、環境変数でLC_ALL='C' を指定するのが役に立つ場合があります。

**-D ACTION, --devices=ACTION**
入力ファイルがデバイス、FIFO、ソケットのいずれかである場合に、ACTIONを使ってその処理を行います。デフォルトのACTIONはreadです。すなわち、デバイスなどを、それが普通のファイルであるかのように、読み込みます。ACTIONがskipならば、デバイスなどを黙ってスキップします。

**-d ACTION, --directories=ACTION**
入力ファイルがディレクトリの場合に、ACTIONを使ってその処理を行います。デフォルトのACTIONはreadです。すなわち、ディレクトリを、それが普通のファイルであるかのように、読み込みます。ACTIONがskipならば、ディレクトリを黙ってスキップします。ACTIONがrecurseなら、grepは各ディレクトリの下にあるすべてのファイルを再帰的に読み込みます。ただし、シンボリックリンクはコマンドラインで指定されたときにのみたどります。これは -rオプションと等価です。

### --exclude=GLOB
コマンドラインで指定されているファイルについては、その名前の尾部が、ワイルドカードによるマッチングでパターンGLOBにマッチするファイルをスキップします。ここで言う「名前の尾部」とは、ファイル名の全体か、 / の直後に始まり / 以外の文字で終るファイル名の最後の部分のことです。また、ディレクトリを再帰検索しているときに出会うファイルについては、ベースネームがGLOBにマッチするファイルをスキップします。ベースネームとは最後の / より後の部分です。パターンには、 *, ?, [...] がワイルドカードとして使えます。 \ を文字の前に置けば、ワイルドカード文字やバックスラッシュ文字を本来の意味で使用できます。
### --exclude-from=FILE
ファイルFILEを読み込み、そこに書かれているファイル名 (ワイルドカード可) のどれかにベースネームがマッチするファイルをスキップします (--excludeの項で説明したワイルドカードのマッチングを使用します)。
### --exclude-dir=GLOB
コマンドラインで指定されているディレクトリのうち、名前の尾部がパターンGLOBにマッチするディレクトリをスキップします。また、ディレクトリを再帰検索しているときに出会うサブディレクトリについては、ベースネームがGLOBにマッチするサブディレクトリをスキップします。GLOB末尾の余分なスラッシュは無視されます。
### -I
バイナリファイルをマッチするデータを含んでいないものとして処理します。これは --binary-files=without-matchオプションと等価です。
### --include=GLOB
ベースネームがGLOBにマッチするファイルのみを検索します (--excludeの項で説明したワイルドカードのマッチングを使用します)。
### -r, --recursive
各ディレクトリの下にあるすべてのファイルを再帰的に読み込みます。ただし、シンボリックリンクはコマンドラインで指定されたときにのみたどります。検索対象のファイルが指定されなかった場合にはgrepは現在のディレクトリを探すことに注意してください。これは -d recurseオプションと等価です。
### -R, --dereference-recursive
各ディレクトリの下にあるすべてのファイルを再帰的に読み込みます。 -rと異なり、すべてのシンボリックリンクを追跡します。

## その他のオプション
### --line-buffered
行ごとに出力を行います。実行速度が落ちるかもしれません。

### -U, --binary
ファイルをバイナリとして扱います。MS-DOSやMS-Windowsの環境下で、grepはデフォルトでは、ファイルがテキストかバイナリかを --binary-filesオプションで記述された方法で推測します。grepはファイルをテキストファイルと判断した場合、オリジナルのファイル内容から (^ や $ を使った正規表現が正しく動作するように) CR文字を取り除きます。 -Uを指定すると、この推測を抑制し、すべてのファイルを読み取って、そのまま手を加えずにマッチ処理へ渡すのです。もしファイルが各行の末尾にCR/LFの組み合わせを持つテキストファイルなら、このオプションのせいで正規表現がうまく働かないことがあるかもしれません。このオプションはMS-DOSやMS-Windows以外のプラットフォームでは効果がありません。

### -z, --null-data
入力と出力のデータを、改行のかわりに、値が0のバイト (ASCII NULL文字) で区切られた一連の行として扱います。 -Zや --nullと同様、このオプションはsort -zなどのコマンドと組み合わせて、行儀の悪いファイル名の処理に使用することができます。

===

| オプション | grep出力                  |
| :--------: | -------------------------- |
|     -r     | 配下ディレクトリを対象に   |
|     -v     | マッチしないものを出力     |
|     -n     | 行番号                     |
|     -H     | ファイル名あり             |
|     -h     | ファイル名なし             |
|     -l     | ファイル名のみ             |
|     -L     | マッチしないファイル名     |
|     -o     | 検索にマッチした部分だけ   |
|     -q     | 結果を出力しない           |
|     -s     | --no-messagesエラー無出力 |

```
# ファイル名にfooとbarを含む。grepのANDをパイプでつなぐ。
ls -l | grep foo | grep bar

# ファイル名にfooを含まない。マッチしないものを出力ときは `-v` をつける。
ls -l | grep -v foo

# directory配下でtimeを含むファイル名だけを出力
grep -rl time directory

# directory配下でt..eを含む行番号とマッチした部分を出力
grep -rno t..e directory

# grepした結果を消す
find ... | grep ... | xargs rm

# grepで正規表現の利用(例:filenameで終わる)
... |grep filename$
```

その他エラーを出力しない
[参考](https://stackoverflow.com/questions/6426363/how-can-i-have-grep-not-print-out-no-such-file-or-directory-errors)

```
grep pattern * -s -R -n
```
